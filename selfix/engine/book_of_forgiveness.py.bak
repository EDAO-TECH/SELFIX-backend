import os, shutil, hashlib, json, subprocess, hmac
from datetime import datetime
from selfix.engine import hmac_utils

BASE = "/opt/SELFIX/forgiveness"
FILES_DIR = f"{BASE}/files"
META_DIR = f"{BASE}/meta"
LOG_DIR = f"{BASE}/logs"
REPORT_DIR = f"{BASE}/reports"

MANIFEST = f"{META_DIR}/manifest.json"
SIGNATURE = f"{META_DIR}/manifest.sig"
VERSIONS = f"{META_DIR}/manifest_versions.json"
HISTORY = f"{LOG_DIR}/forgiveness_history.log"
EXEC_LOG = f"{META_DIR}/execution.log"

SECRET_KEY_PATH = "/opt/SELFIX/selfix/engine/secret.key"
TARGET_LIST = "/opt/SELFIX/forgiveness_targets.txt"

for path in [FILES_DIR, META_DIR, LOG_DIR, REPORT_DIR]:
    os.makedirs(path, exist_ok=True)

def _log(msg):
    with open(HISTORY, "a") as f:
        f.write(f"[{datetime.now().isoformat()}] {msg}\n")

def _hash(path):
    with open(path, "rb") as f:
        return hashlib.sha256(f.read()).hexdigest()

def _load_manifest():
    if not os.path.exists(MANIFEST):
        return {}

    # ‚úÖ Only verify signature if it exists
    if os.path.exists(SIGNATURE):
        hmac_utils.verify_manifest(MANIFEST, SIGNATURE, SECRET_KEY_PATH)

    with open(MANIFEST, "r") as f:
        return json.load(f)

def _save_manifest(data):
    with open(MANIFEST, "w") as f:
        json.dump(data, f, indent=2)
    hmac_utils.sign_manifest(MANIFEST, SIGNATURE, SECRET_KEY_PATH)

def _update_versions(name, entry):
    versions = {}
    if os.path.exists(VERSIONS):
        with open(VERSIONS, "r") as f:
            versions = json.load(f)
    versions.setdefault(name, []).append(entry)
    with open(VERSIONS, "w") as f:
        json.dump(versions, f, indent=2)

def seal_file(path, strict=False):
    if not os.path.exists(path):
        print(f"‚ùå Not found: {path}")
        return

    name = os.path.basename(path)

    if strict and os.path.exists(TARGET_LIST):
        with open(TARGET_LIST) as f:
            targets = [line.strip() for line in f.readlines()]
        if path not in targets and name not in targets:
            print(f"‚õî Not in forgiveness_targets.txt: {path}")
            return

    print(f"üß™ QC: Running {name}")
    try:
        subprocess.run(["python3", path], capture_output=True, text=True, check=True, timeout=10)
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Failed: {e}")
        _log(f"QC FAILED: {name} ‚Äî {e}")
        return

    shutil.copy2(path, f"{FILES_DIR}/{name}")
    file_hash = _hash(path)

    forgiven_by = input("üìú Forgiven by: ")
    reason = input("‚úèÔ∏è Reason for sealing: ")
    alias = input("üîñ Optional alias: ")

    entry = {
        "original_path": path,
        "hash": file_hash,
        "executed": True,
        "qc_passed": True,
        "timestamp": datetime.now().isoformat(),
        "forgiven_by": forgiven_by,
        "reason": reason,
        "alias": alias or name
    }

    manifest = _load_manifest()
    manifest[name] = entry
    _save_manifest(manifest)
    _update_versions(name, entry)

    _log(f"SEALED: {name} ‚úÖ")
    print(f"‚úÖ {name} sealed and certified.")

def verify_all():
    manifest = _load_manifest()
    results = []

    for name, info in manifest.items():
        path = info["original_path"]
        if not os.path.exists(path):
            msg = f"‚ö†Ô∏è Missing: {path}"
            results.append(msg)
            continue
        if _hash(path) != info["hash"]:
            msg = f"‚ùå TAMPERED: {name}"
            results.append(msg)
            _log(msg)
        else:
            msg = f"‚úÖ Verified: {name}"
            results.append(msg)

    report = f"{REPORT_DIR}/verify_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
    with open(report, "w") as f:
        f.write("\n".join(results))
    print("\n".join(results))

def restore_file(name):
    manifest = _load_manifest()
    if name not in manifest:
        print(f"‚ùå Not sealed: {name}")
        return

    src = f"{FILES_DIR}/{name}"
    dst = manifest[name]["original_path"]

    shutil.copy2(src, dst)
    _log(f"RESTORED: {name} to {dst}")
    print(f"‚ôªÔ∏è Restored: {name}")

    # Post-restore verification
    if _hash(dst) == manifest[name]["hash"]:
        print("‚úÖ Integrity verified after restore")
        _log(f"VERIFY OK: {name}")
    else:
        print("‚ùå Verify failed after restore")
        _log(f"VERIFY FAIL: {name}")
